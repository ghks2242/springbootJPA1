    # 핵심 라이브러리
        - 스프링 MVC
        - 스프링 ORM
        - JPA, 하이버네이트
        - 스프링 데이터 JPA

    # 기타 라이브러리
        - H2 데이터 베이스 클라이언트
        - 커넥션 풀: 부트 기본은 HikariCP
        - WEB(thymeleaf)
        - 로깅 SLF4J(인터페이스) & LogBack(구현체)
        - 테스트


## application.yml 설정시 띄어쓰기가 매우중요!!!!


    # 엔티티에는 가급적 Setter 를 사용하지말자
        - Setter 가 모두 열려있다면 변경포인트가많아서 유지보수 어렵다.

    # 모든연관관계는 지연로딩으로 설정!
        - 즉시로딩(EAGER)(ex. Member테이블은 조회하면 Member테이블과 연관되어있는 모든 테이블을 조회함) 은 예측이 어렵고 어떤 sql 이 실행될지 추적하기 어렵다
          특히 jpql 을 실행할때 N+1 문제가 자주발생한다.

        - 실무에서 모든 연관관계는 지연로딩(LAZY)으로 설정해야한다.
        - 연관된 엔티티를 함께 db 애서 조회해야하면, fetch join 또는 엔티티 그래프 기능을 사용한다.
        - @XToOne(OneToOne, ManyToOne) 관계는 기본이 즉시로딩이므로 직접 지연로딩으로 설정해야한다.


    # 컬렉션은 필드에서 초기화 하자
        - 컬렉션은 필드에서 초기화 하는것이 안전하다. (ex. private List<Order> orders = new ArrayList<>(); )
        - null 문제에서 안전하다.
        - 하이버네이트는 엔티티를 영속화할때 컬렉션을 감싸서 하이버네이트가 제공하는 내장컬렉션으로 변경한다.
          만약 getOrders() 처럼 임의의 메서드에서 컬렉션을 잘못 생성하면 하이버네이트 내부 매커니즘에 문제가 발생할수있다.
          따라서 필드레벨에서 생성하는것이 가장 안전하고 코드도 간결하다.


    # 테이블명과 컬럼명 생성전략
        - 하이버네이트 기존구현 : 엔티티의 필드명을 그대로 테이블명으로사용
        ( SpringPhysicalNamingStrategy)

        - 스프링부트 신규설정(엔티티(필드) -> 테이블(컬럼))
            - 카멜케이스 -> 언더스코어(memberPoint -> member_point)
            - .(점) -> _(언더스코어)
            - 대문자 -> 소문자


        논리명 생성: 명시적으로 컬럼, 테이블명을 직접 적지않으면 ImplicitNamingStrategy 사용
                  spring.jpa.hibernate.naming.implicit-strategy: 테이블이나, 컬럼명을 명시하지 않을때 논리명적용
                  (테이블, 컬럼명이 적혀있지않을때 적용)

        물리명 적용 : spring.jpa.hibernate.naming.physical-strategy : 모든 논리명에 적용됨, 실제 테이블에 적용
                   (테이블, 컬럼명이 적혀있던 적혀있지않던 적용)